[{"title":"关于各种时间标准","url":"http://example.com/2019/02/23/关于各种时间标准/","content":"关于各种时间标准(时间系统)编程中, 许多的定时任务都与”标准时间”有关, 程序中对时间处理不当可能导致难以排查的问题, 甚至在金融, 通信, 电力, 交通等行业中引起重大bug, 产生巨大危害. 作为程序员, 应当对时间表示的方法有所了解, 明白各种时间表示的区别及可能导致程序bug的特殊时间点.  \n\n\n0x00 在阅读之前本文接下来的所有内容遵循以下规约:\n\n所有的时间将被用 yyyy-mm-dd hh:mm:ss(zzz) 的形式严格表达.\n未被严格表示的时间都默认为协调世界时(UTC).\n未经特殊表达的秒的定义均遵循国际单位制1967年的原子秒定义.\n\n0x01 常见标准时间格林尼治标准时间(GMT)通常世界时(UT)也指代GMT本初子午线被定义在通过格林尼治的经线, 理论上来说, 格林尼治标准时间的正午是指当太阳横穿格林尼治子午线时的时间. 由于地球在它的椭圆轨道里的运动速度不均匀, 这个时刻可能和实际的太阳时相差16分钟. 自1924年2月5日开始, 格林尼治天文台每隔一小时会向全世界发放调时信息. 1960年以前, GMT曾作为基本时间计量系统被广泛应用. 由于地球自转速度变化的影响, 它不是一种均匀的时间系统. 但是, 因为它与地球自转的角度有关, 所以即使在1960年作为时间计量标准的职能被历书时(ET)取代以后, 世界时对于日常生活,天文导航,大地测量和宇宙飞行器跟踪等仍是必需的. 同时, 精确的世界时是地球自转的基本数据之一, 可以为地球自转理论,地球内部结构,板块运动,地震预报以及地球,地月系,太阳系起源和演化等有关学科的研究提供必要的基本资料. \n历书时(ET)它是由天体力学的定律确定的均匀时间﹐又称牛顿时. 由于地球自转的不均匀性﹐1958年国际天文学联合会决议﹐自1960年开始用历书时代替世界时作为基本的时间计量系统﹐并规定世界各国天文年历的太阳,月球,行星历表﹐都以历书时为准进行计算. \n国际原子时(TAI)原子时计量的基本单位是原子时秒. 它的定义是: 铯原子基态的两个超精细能级间在零磁场下跃迁辐射9,192,631,770周所持续的时间. 1967年第十三届国际计量大会决定, 把在海平面实现的上述原子时秒, 规定为国际单位制中的时间单位.根据原子时秒的定义, 任何原子钟在确定起始历元后, 都可以提供原子时. 由各实验室用足够精确的铯原子钟导出的原子时称为地方原子时. 目前, 全世界大约有20多个国家的不同实验室分别建立了各自独立的地方原子时. 国际时间局比较,综合全球范围240台原子钟数据, 最后确定的原子时, 称为国际原子时, 简称TAI.TAI起点定在1958年1月1日0时0分0秒(UT), 即规定在这一瞬间原子时时刻与世界时刻重合. 但事后发现, 在该瞬间原子时与世界时的时刻之差为0.0039秒. 这一差值就作为历史事实而保留下来. 在确定原子时起点之后, 由于地球自转速度不均匀, 世界时与原子时之间的时差便逐年积累.   \n协调世界时(UTC)协调世界时是以原子时秒长为基础, 在时刻上尽量接近于世界时的一种时间计量系统. 这是日常编程工作中最常接触使用的时间标准.世界时的时间计量系统是基于地球自转时间. 太阳的东升西落是长期以来人们计算时间的主要依据, 太阳走到天空中最正中的位置时, 就是12时. 在世界时(UT)的计量系统中, 一秒有多长, 取决于一天(地球自转一周的时间)有多长, 但地球的自转速度并不是恒定的, 地球自转时快时慢, 则一秒的定义也随之浮动, 这无疑会给精密计量场合带来困扰, 而原子时准确稳固定义了一秒的长度, 由此则导致了上文TAI的介绍中提到的世界时与原子时之间逐年积累的时差, 若不将原子时加以修正, 根据国际计量局测算, 约5000年后原子时将和世界时差1小时, 也即是5000年后正午太阳将在13:00 直射地球, 且这个偏移还将继续堆积.为了应对这种情况, 协调世界时的折衷时标于1972年面世. 为确保协调世界时与世界时相差不会超过0.9秒, 在有需要的情况下会在协调世界时内加上正或负闰秒. 因此协调世界时与国际原子时之间会出现若干整数秒的差别, 两者之差逐年积累, 采用闰秒的方法使协调时与世界时的时刻相接近, 两者偏差不超过0.9s. 它保持时间尺度的均匀性(但破坏了时间的连续性), 近似地反映地球自转的变化. 按国际无线电咨询委员会(CCIR)通过的关于UTC的修正案, 从1972年1月1日起UTC与UT之间的差值最大可以达到±0.9s. 位于巴黎的国际地球自转事务中央局负责决定何时加入闰秒. 一般会在每年的6月30日,12月31日的最后一秒进行调整. 这套时间系统被应用于许多互联网的标准中.\nGPS时(GPST)GPS时(GPST)是由GPS星载原子钟和地面监控站原子钟组成的一种原子时基准, 与国际原子时(TAI)保持有19s的常数差, 并在GPS标准历元1980年1月6日零时与UTC保持一致. CPS时间在0~604800s之间变化, 0s是每星期六午夜且每到此时GPS时间重新设定为0s, GPS周数加1. 为了保持系统定位,导航,授时的连续性, GPS时不引入闰秒. 实际上GPS的时和协调世界时有一个公式, 因为这两个时间系统在1980年1月6日0时是一致的, 而UTC时存在闰秒, 因而一段时间后, 两种时间系统会相差n个整秒. (n为这段时间内UTC积累的闰秒数)当前最近一次闰秒的时间点为2017-01-01(UTC), 换算公式为GPS = UTC + 18s.  \n关于GPS周:当GPS时间记录满604800s时, GPS周数+1. GPS周数起始于 1980-01-06 00:00(UTC), GPS周数范围为0到1023, 超过上限以后将回滚为0, 然后继续循环计数. 因此一个GPS循环=1024周=7168天=19.62年, 目前为止仅有的一次周数回滚发生在1999-08-22 00:00(GPST).\n0x02 关于闰秒(leap second)闰秒的目的是为了在保持通用的时间标准于人类起居时间概念在较长时间尺度内的统一, 但对于授时机构,通信,航天,电子等时间精度要求较高的领域而言需要时间保持连续性. 全球卫星导航精确到纳秒, 而卫星发射需要精确到微秒以上. 闰秒的出现, 起到弥补和修正的作用, 但客观上导致了时间的中断. 目前, 全球已经进行了27次闰秒, 均为正闰秒. 最近一次闰秒在 2017-01-01 00:59:59(UTC) 出现. 这也是本世纪的第五次闰秒.  \n置闰细节:增加正闰秒时, 这一秒是增加在第二天的00:00:00之前, 效果是延缓UTC第二天的开始. 当天23:59:59的下一秒被记为23:59:60, 然后才是第二天的00:00:00.如果是负闰秒的话, 23:59:58的下一秒就是第二天的00:00:00了, 但目前还没有负闰秒调整的需求.   \n闰秒对程序造成的影响以下内容援引自新闻媒体报道:\n\n据国外媒体报道, 上周日晚Reddit,Mozilla和Gawker等多家网站遭遇短暂的技术故障, 原因在于在将”闰秒”加入世界原子钟的过程中, 支撑这些网站操作的软件受到影响.   \n\n\n上周六, 格林威治时间午夜, 从6月跨越到7月的过程中, 地球官方时间将回拨一秒, 以保持和地球每日自转同步. 根据网上的多篇报道, 包括Liunx操作系统和Java应用平台在内的多个软件基础平台无法处理这多出来的一秒. \n\n\n新闻聚合和讨论网站Reddit就遭遇”Java/Cassandra”问题. Java/Cassandra”是Facebook用Java开发的开源数据库. 不过Reddit没有回应关于此事的置评要求.   \n\n\n与此同时, Mozilla网站稳定性工程师, 同时又是火狐浏览器开发者的Eric Ziegenhorn发布了一份bug报告, 称Mozilla正遭遇Hadoop问题. Hadoop是另一个用Java开发的开源平台. 自从午夜出现问题之后, Ziegenhorn 同样将这一问题归咎于闰秒.   \n\n\n其他人则抱怨Linux服务器出现问题. 根据BuzzFeed的报道, Foursquare,Yelp,LinkedIn,Gawker和StumbleUpon同样受到闰秒bug的困扰. 这5家网站中只有Gawker回应了置评要求, 声称它因为使用了Tomcat网络服务器架设自己的网站而遭遇”闰秒”问题.   \n\n\n去年9月, 谷歌在一篇帖子中详细阐述了如何处理闰秒问题. 这家网络巨头使用了一种叫做”闰秒弥补”的技术, 也就是在官方闰秒到来之前, 逐步在自己的系统时钟中增加毫秒.   \n\n\n谷歌表示, 这意味着当时间在午夜新增一秒, 公司的时钟已经考虑到了这一点, 并通过偏移时间的方法来解决. 公司所有服务器可以继续正常提供服务, 而根本不用顾及”闰秒”问题.   \n\n历史闰秒统计表:\n0x03 关于时间戳(timestamp)时间戳也是编程工作中接触频率很高的时间表示法. 一般的时间戳指代Unix 时间戳(或称POSIX时间), 是一个用于描述时间点的系统, 时间戳的数值等于1970-01-01 00:00:00(UTC) 起至现在的总秒数减去经历的闰秒数. 由于时间戳数值中并不包含闰秒数, 故在于UTC时间的换算中可把所有时间都按一分钟60秒计算, 无须考虑一分钟61秒的闰秒情况.(另在收集资料的过程中, 发现百度百科对时间戳的定义有误, 百科中介绍起始时间为格林威治时间1970-01-01- 00:00:00(GMT), 实际应为UTC时间.) 由于时间戳为相对时间, 故不存在时区区别, 本文写作时间 2019-02-23 16:07:24(UTC) 全时区的时间戳都为1550938044\n时间戳如何处理闰秒以1998年12月闰秒为例, 展示时间戳对闰秒的处理细节:\n2038年问题在 2038-01-19 03:14:07(UTC) 这一时刻, 时间戳将耗尽32bit所能表达的最大秒数, 超过此一瞬间, 时间将会被掩盖(wrap around)且在内部被表示为一个负数, 并造成程序无法工作, 因为它们无法将此时间识别为2038年, 而可能会依个别实作而跳回1970年或1901 年. 错误的计算及动作可能因此产生, 被称为2038年问题.\n0x04 资料附录TimeAndDate\nGPSclock\nTimescales\n","categories":[],"tags":[]},{"title":"linux用户登录时自动运行脚本","url":"http://example.com/2019/02/18/linux用户登录时自动运行脚本/","content":"[日志]linux用户登录时的信息展示0x00 前言多人协作的服务器上, 需要在用户登录时给予关于服务器的相关操作注意事项及其基本信息的展示. 通过保存自动运行脚本, 完成此需求.\n\n\n0x01 登陆自动运行脚本在一般的linux发行版中(如centos), /etc/issue里存放了用户成功登录前显示的信息;/etc/motd存放了用户成功登录后显示的信息.但是在ubuntu中有些不一样, 它相关的是/etc/update-motd.d/文件夹下的几个脚本, 如下所示:/etc/update-motd.d/脚本列表:00-header10-help-text90-updates-available91-release-upgrade98-fsck-at-reboot98-reboot-required当我们通过ssh登录主机时，会输出/var/run/motd.dynamic 中的信息.  \nWelcome to Ubuntu 16.04.1 LTS (GNU&#x2F;Linux 2.6.32-042stab133.2 x86_64) * Documentation:  https:&#x2F;&#x2F;help.ubuntu.com * Management:     https:&#x2F;&#x2F;landscape.canonical.com * Support:        https:&#x2F;&#x2F;ubuntu.com&#x2F;advantage\n\n而/var/run/motd.dynamic 中的信息就是用户登录时系统已root身份执行上述/etc/update-motd.d/ 下面的几个脚本所生成的. Ubuntu每次登陆时都会默认显示如上提示信息, 可以删除相关脚本内容去除.\nLinux下实现登陆自动加载指令, 有两种方式  \n\n在 /etc/motd 文件末尾直接写入脚本内容\n在 /etc/profile.d 文件夹中放置.sh脚本文件\n\n示例一：通过root用户 输入命令 vim /etc/motd修改motd文件 ，在该文件中加入内容 echo “Hello,Welcome to Linux!”退出用户，下次登陆显示结果：\nWelcome to Ubuntu 16.04.1 LTS (GNU&#x2F;Linux 2.6.32-042stab133.2 x86_64) * Documentation:  https:&#x2F;&#x2F;help.ubuntu.com * Management:     https:&#x2F;&#x2F;landscape.canonical.com * Support:        https:&#x2F;&#x2F;ubuntu.com&#x2F;advantageecho &quot;Hello,Welcome to Linux!&quot;Last login: Mon Feb 18 08:46:22 2019 from 211.97.3.xxxroot@la:~#\n\n示例二：在 /etc/profile.d 文件夹中加入shell脚本, 实现同样的效果:进入该目录, 创建 test.sh 文件:\n[root@spark elon]# cd &#x2F;etc&#x2F;profile.d&#x2F;[root@spark profile.d]# vi test.shecho &quot;Hello,The twice time to login in linux!&quot;\n\nWelcome to Ubuntu 16.04.1 LTS (GNU&#x2F;Linux 2.6.32-042stab133.2 x86_64) * Documentation:  https:&#x2F;&#x2F;help.ubuntu.com * Management:     https:&#x2F;&#x2F;landscape.canonical.com * Support:        https:&#x2F;&#x2F;ubuntu.com&#x2F;advantageLast login: Mon Feb 18 08:46:57 2019 from 211.97.3.xxxHello,The twice time to login in linux!\n\n0x02 放置信息文本在/root/information/下新建基础信息文件svr_info.txt\n#################################################- 服务器情况#  - ip地址:\t198.46.xxx.xxx#  - 控制面板:\tmanage.xxxx.cxm#  - 带宽:\t1.95 TB#################################################- 端口占用情况#  - 22:\tssh通道#  - 25:\tSMTP服务#  - 80:\thttp端口(Apache占用)#  - 443:\t暂未使用#  - 111:\trpcbind################################################\n\n0x03 放置显示脚本在/etc/profile.d下创建文件login_info.sh\ncat &#x2F;root&#x2F;information&#x2F;svr_info.txt\n\n\n","categories":[],"tags":["运维日志"]},{"title":"计算机疑难杂症","url":"http://example.com/2019/02/07/计算机疑难杂症/","content":"计算机疑难杂症休眠时间设置无效\n\n计算机\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Power\\PowerSettings\\238C9FA8-0AAD-41ED-83F4-97BE242C8F20\\7bc4a2f9-d8fc-4469-b07b-33eb785aaca0\n注册表Attributes项由1改为2\n","categories":[],"tags":[]},{"title":"个人编程规范","url":"http://example.com/2019/01/09/个人编程规范/","content":"个人编程规范1.命名规约\n\n强制命名原则\n\n代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。\n代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。\n\n\n\n变量命名  \n&#x2F;&#x2F;全小写, 单词间用下划线连接  java_script  this_is_a_long_example  \n\n函数命名  \n&#x2F;&#x2F;驼峰命名法, 单词第一个字母大写, 但首字母除外  javaScript  thisIsALongExample  \n\n类命名  \n&#x2F;&#x2F;帕斯卡命名法, 所有单词首字母大写  JavaScript  \n\n常量  \n&#x2F;&#x2F;全部字母大写  JAVASCRIPT  THIS_IS_A_LONG_EXAMPLE  \n\n\n\n词汇缩写\n\n\n\n\n缩写\n全称\n\n\n\naddr\naddress\n\n\napp\nApplication\n\n\narg\nArgument\n\n\navg\naverage\n\n\nDB\nDatabase\n\n\nbmp\nBitmap\n\n\nbtn\nButton\n\n\nbuf\nBuffer\n\n\ncalc\nCalculate\n\n\nchar\nCharacter\n\n\nclr\ncolor\n\n\ncmd\nCommand\n\n\ncmp\nCompare\n\n\ncol\nColumn\n\n\ncur\nCurrent\n\n\ndbg\nDebug\n\n\ndef\ndefault\n\n\ndel\nDelete\n\n\ndest / dst\nDestination\n\n\ndev\nDevice\n\n\ndict\ndictionary\n\n\ndiff\ndifferent\n\n\ndir\ndirectory\n\n\ndisp\nDisplay\n\n\ndiv\nDivide\n\n\ndlg\nDialog\n\n\ndoc\nDocument\n\n\ndrv\nDriver\n\n\ndyna\nDynamic\n\n\nenv\nEnvironment\n\n\nerr\nerror\n\n\nex/ext\nExtend\n\n\nexec\nexecute\n\n\nflg\nflag\n\n\nfunc / fn\nFunction\n\n\ngrp\ngroup\n\n\nimg\nImage\n\n\ninfo\nInformation\n\n\ninit\nInitial/Initialize/Initialization\n\n\nins\nInsert\n\n\nlen\nLength\n\n\nlib\nLibrary\n\n\nlnk\nLink\n\n\nlog\nlogical\n\n\nlst\nList\n\n\nmax\nmaximum\n\n\nmem\nMemory\n\n\nmgr / man\nManage / Manager\n\n\nmid\nmiddle\n\n\nmin\nminimum\n\n\nmsg\nMessage\n\n\nmtch\nMatch\n\n\nnum\nNumber\n\n\nobj\nObject\n\n\nofs\nOffset\n\n\norg\nOrigin / Original\n\n\nparam\nParameter\n\n\npic\npicture\n\n\npkg\npackage\n\n\npnt / pt\nPoint\n\n\npos\nPosition\n\n\npre / prev\nprevious\n\n\nprg\nprogram\n\n\nprn\nPrint\n\n\nproc\nProcess / Procedure\n\n\npsw\nPassword\n\n\npub\nPublic\n\n\nrc\nrect\n\n\nres\nResource\n\n\nret\nreturn\n\n\nscr\nscreen\n\n\nsec\nSecond\n\n\nseg\nSegment\n\n\nsrc\nSource\n\n\nsrch\nSearch\n\n\nstd\nStandard\n\n\nstg\nStorage\n\n\nstm\nStream\n\n\nstr\nString\n\n\nsync\nSynchronization\n\n\nsys\nSystem\n\n\ntbl\nTable\n\n\ntemp / tmp\nTemporary\n\n\ntst\nTest\n\n\ntxt\ntext\n\n\nunk\nUnknown\n\n\nvar\nVariable\n\n\nver\nVersion\n\n\nwnd\nWindow\n\n\ncnt / cc\ncount\n\n\n","categories":[],"tags":[]},{"title":"可信书单","url":"http://example.com/2019/01/09/可信书单/","content":"可信出版社名单注: 此名单为部分高质量计算机类著作高频出版社列表, 日后看到合适的书籍时, 对照此名单可无脑下单\n\n\n\n人民邮电出版社\n\n电子工业出版社\n\n机械工业出版社\n\n清华大学出版社\n\n高等教育出版社图灵丛书\n书单技术类\nPython基础教程（第3版）\n\n编程珠玑\n\nOpenCV3编程入门\n\n现代编译原理 C语言描述 修订版\n\n简单微积分\n\n编程之美\n\n高效算法\n\n编码\n\n程序员的英语\n\n\n非技术类\n程序员健康指南\n乔布斯传\n\n(乔布斯传一定要看准作者艾萨克森, 国内好多蹭热度的垃圾书)\n\n别逗了, 费曼先生\n食物与厨艺\n理想国\n1984\n孤独深处\n黑客与画家\n计算机二级Python\n计算机程序设计艺术\n\n","categories":[],"tags":[]},{"title":"Qt(C++)与python混编经验记录","url":"http://example.com/2018/02/07/QT(C++)与python混编经验分享/","content":"简述刚好遇到了需求, 研究了下python和C/C++的混合编程. 对比了原生API和Cython, SWIG这类扩展库, 最终还是决定采用原生API方案.\n\n\n混合编程问题分为在C++中插入python 和 在python中插入C++, 本文只讨论在python中插入C++代码的情况.Python3/C API 参考手册: https://docs.python.org/3/c-api/index.htmlPython2/C API 参考手册: https://docs.python.org/2.7/c-api/index.html环境Win10 64bitQt 5.10.0 (MSVC 2015, 32 bit) with MinGW 32bitPython 3.6.3 32bit\n\n实现\n代码\n#include &lt;Python.h&gt;int Widget::pow_function_from_python(int a, int b) &#123;    Py_Initialize();&#x2F;&#x2F;初始化python解释器    if ( !Py_IsInitialized() ) return -1;&#x2F;&#x2F;检查初始化    int res;    PyObject *pModule,*pFunc;    PyObject *pArgs, *pValue;    pModule &#x3D; PyImport_Import(PyUnicode_FromString(&quot;math&quot;));&#x2F;&#x2F;导入模块    pFunc &#x3D; PyObject_GetAttrString(pModule, &quot;pow&quot;);&#x2F;&#x2F;获取函数    if ( !pFunc || !PyCallable_Check(pFunc) ) return -1;&#x2F;&#x2F;检查函数是否存在    &#x2F;&#x2F;构造参数    pArgs &#x3D; PyTuple_New(2);    PyTuple_SetItem(pArgs,0, Py_BuildValue(&quot;i&quot;,a));    PyTuple_SetItem(pArgs,1, Py_BuildValue(&quot;i&quot;,b));    &#x2F;&#x2F;调用函数    pValue &#x3D; PyObject_CallObject(pFunc, pArgs);    &#x2F;&#x2F;处理返回值    res &#x3D; PyLong_AsLong(pValue);    Py_Finalize();    return res;&#125;\n\n\n所有Python元素，module、function、tuple、string等等，实际上都是PyObject。C语言里操纵它们，一律使用PyObject *。\nPython的类型与C语言类型可以相互转换。Python类型XXX转换为C语言类型YYY要使用PyXXX_AsYYY函数；\nC类型YYY转换为Python类型XXX要使用PyXXX_FromYYY函数。\n也可以创建Python类型的变量，使用PyXXX_New可以创建类型为XXX的变量。\n若a是Tuple，则a[i] = b对应于 PyTuple_SetItem(a,i,b)，有理由相信还有一个函数PyTuple_GetItem完成取得某一项的值。\n不仅Python语言很优雅，Python的库函数API也非常优雅。\n\n\n\n头文件\n#include &lt;Python.h&gt;\n\n** 注意: python.h 中定义了一些预处理宏, 可能与其他标准头文件冲突, 故必须将python.h 在其他头文件之前包含. 在Qt中, python的object.h使用slot作为变量名, 与Qt的宏定义冲突, 可如下修改避免.**\n#undef slots     \t\t&#x2F;&#x2F;这里取消slots宏定义PyType_Slot *slots; &#x2F;* terminated by slot&#x3D;&#x3D;0. *&#x2F;#define slots Q_SLOTS\t&#x2F;&#x2F;这里再恢复\n\n函数介绍\n\nvoid Py_Initialize()初始化python解释器. 此函数应该在所有python API函数使用前被调用(Py_SetProgramName(), Py_SetPythonHome() 及 Py_SetPath()例外), 重复调用时为空操作.\nPy_IsInitialized()返回python解释器初始化状态. 强烈建议检查初始化状态, 未初始化情况下直接调用API函数将引起程序崩溃, 且无任何调试信息.\nint PyRun_SimpleString()执行一行简单的python代码, 成功返回0, 失败返回-1, 执行失败无调试信息.\nPy_Finalize()取消所有python解释器的初始化, 回收资源.\nPyImport_Import()导入模块, 对应python代码中的import.\nPyUnicode_FromString()将C字符串转化为python Unicode字符串.(仅python3支持).\nPyObject_GetAttrString()获取python函数.\nPyTuple_New构造python元组.\nPyTuple_SetItem()设置元组变量.\nPyObject_CallObject()调用python函数.\nPyLong_AsLong转换python中的long类型数据为C语言long型.\nPy_BuildValue() 把C++的变量转换成一个Python对象。当需要从C++传递变量到Python时，就会使用这个函数。此函数有点类似C的printf，但格式不同。常用的格式有 s 表示字符串 i 表示整型变量 f 表示浮点数 O 表示一个Python对象.\n\n编译需添加python的头文件和库文件 在Qt中具体做法为在pro文件中添加:INCLUDEPATH +&#x3D; -I C:\\Users\\AndyF\\AppData\\Local\\Programs\\Python\\Python36-32\\includeLIBS +&#x3D; -LC:\\Users\\AndyF\\AppData\\Local\\Programs\\Python\\Python36-32\\libs -lpython36\n在VisualStudio下, 可用命令进行编译cl my_python.c -IC:\\Python27\\include C:\\Python27\\libs\\python27.lib\n在linux下, 编译命令为gcc my_python.c -o my_python -I&#x2F;usr&#x2F;include&#x2F;python2.7&#x2F; -lpython2.7\n参考文献c++与Python3互相调用QT与Python混合编程经验记录在c中内嵌python编程如何实现 C/C++ 与 Python 的通信？C++嵌入Python程序（二）：参数传入及返回C++调用Python浅析\n\n","categories":[],"tags":[]},{"title":"我想, 我一定是黑夜的孩子","url":"http://example.com/2017/11/03/我想, 我一定是黑夜的孩子/","content":"一盏孤灯, 几颗星辰.夜深 是工作的好时候.\n\n这大概是整个世界最安静的时候, 台灯把你的注意力限制在你的桌面上, 微信QQ的消息不再让手机响个不停, 这大概是我一天中最能专注的时候. 看着便利贴上的待办一个个被划掉, 面对着代码思路清晰, 秒速debug, 脑子里各种idea蹦动跳跃, 感觉生产力又回到了巅峰状态.并不需要咖啡因, 猫在桌子前就是一夜.我想, 我一定是黑夜的孩子.\n","categories":[],"tags":[]},{"title":"qwt开发速记","url":"http://example.com/2017/06/24/qwt开发速记/","content":"头文件#include &lt;qwt_plot.h&gt;#include &lt;qwt_plot_grid.h&gt;#include &lt;qwt_plot_zoomer.h&gt;#include &lt;qwt_plot_panner.h&gt;#include &lt;qwt_plot_magnifier.h&gt;\n\n类QwtPlot\nsetTitle(PlotName) //设置plot标题\nsetCanvasBackground() //设置画布背景颜色\nresize(600, 400)\nsetAxisScale(QwtPlot::xBottom,0,2048) //设置坐标范围\nreplot() //刷新曲线\ncanvas() //返回画布\ncanvas()-&gt;setCursor //设置鼠标样式\n\nQwtPlotCurve\nsetTitle(CurveName) //设置曲线标题\nsetPen(PenColor, PenWidth); //设置画笔\nsetRenderHint(QwtPlotItem::RenderAntialiased,true) //设置反锯齿\nsetCurveAttribute(QwtPlotCurve::Fitted, true) //平滑曲线\nsetSamples() //设置样本\nattach(QwtPlot) //附加在哪一个Plot上\n\nQwtPlotZoomer(plot-&gt;canvas())\nsetEnabled(false)\n\nQwtPlotPanner(plot-&gt;canvas())\nsetEnabled(false)\n\nQwtPlotMagnifier(plot-&gt;canvas())\nsetEnabled(false)\n\n","categories":[],"tags":[]},{"title":"QwtPlotZoomer","url":"http://example.com/2017/06/20/QwtPlotZoomer/","content":"\n\n#include &lt;qwt_plot_zoomer.h&gt;#include &lt;qwt_plot_panner.h&gt;#include &lt;qwt_plot_magnifier.h&gt;  QwtPlotZoomer *zoomer = new QwtPlotZoomer( canvas );                     //选择图形局部放大 zoomer-&gt;setRubberBandPen( QColor( Qt::blue ) ); //勾选扩大区域边界颜色 zoomer-&gt;setMousePattern( QwtEventPattern::MouseSelect2, Qt::RightButton, Qt::ControlModifier );//ctrl+右键==回复到原始状态  zoomer-&gt;setMousePattern( QwtEventPattern::MouseSelect3, Qt::RightButton );       //右键==恢复到上一次扩大之前的状态  QwtPlotPanner *panner = new QwtPlotPanner( canvas );                                   //默认的左键移动功能 panner-&gt;setMouseButton( Qt::RightButton );        //设置哪个按钮移动画布  如果不设置(注册掉当前行)按钮默认为左键为移动 QwtPlotMagnifier magnifier = new QwtPlotMagnifier( canvas );                 //默认的滑轮及右键缩放功能  图形的整体缩放 magnifier-&gt;setMouseButton(Qt::LeftButton);     //设置哪个按钮与滑轮为缩放画布  如果不设置(注册掉当前行)按钮默认为滑轮以及右键为缩放           对于移动以及图形的整体缩放，通过void setMouseButton( Qt::MouseButton, Qt::KeyboardModifiers = Qt::NoModifier );便能修改自己对应功能的按钮。       对于图形局部放大，也是通过设置setMouseButton，但是参数有所不同，void setMousePattern( MousePatternCode, Qt::MouseButton button, Qt::KeyboardModifiers = Qt::NoModifier );对于第一个参数，由对应的文档可知，有MousePatternCode是枚举型，有7个可选值，其中6个MouseSelect1-6，是设置鼠标模型值。Qwt例子中局部放大(左键放大，右键还原上一级图形，ctrl+右键还原原始图形)，是通过设置2,3.。具体的含义可能由于自己英文水平有限，在文档中没有找到，采用了最笨的方法进行了测试，得到1-3对应的功能，但是4-6却没有能够知道其作用，如果有知道的朋友，麻烦告诉一下，在此先谢过。模式一 //默认右键恢复原样···放大的方式可以自定义zoomer-&gt;setMousePattern( QwtEventPattern::MouseSelect1, Qt::LeftButton, Qt::ControlModifier );//crtl+左键 放大\t 右键恢复原样\tzoomer-&gt;setMousePattern( QwtEventPattern::MouseSelect1, Qt::RightButton, Qt::ControlModifier );//ctrl+右键 放大 右键恢复原样zoomer-&gt;setMousePattern( QwtEventPattern::MouseSelect1, Qt::LeftButton );\t//左键放大\t右键恢复原样zoomer-&gt;setMousePattern( QwtEventPattern::MouseSelect1, Qt::RightButton );\t//右键放大与恢复重叠 不推荐使用 模式二 //默认左键放大···恢复原样的方式可以自定义    zoomer-&gt;setMousePattern( QwtEventPattern::MouseSelect2, Qt::LeftButton, Qt::ControlModifier );//左键 放大\t ctrl+左键恢复\t    zoomer-&gt;setMousePattern( QwtEventPattern::MouseSelect2, Qt::RightButton, Qt::ControlModifier );//左键 放大\t ctrl+右键恢复原样    zoomer-&gt;setMousePattern( QwtEventPattern::MouseSelect2, Qt::LeftButton );//左键放大与左键恢复重叠 不推荐使用    zoomer-&gt;setMousePattern( QwtEventPattern::MouseSelect2, Qt::RightButton );//左键放大\t右键恢复原样模式三 //默认左键放大、右键恢复原样···恢复上一级原样可以自方式定义    zoomer-&gt;setMousePattern( QwtEventPattern::MouseSelect3, Qt::LeftButton, Qt::ControlModifier );//左键 放大\t右键恢复原样 ctrl+左键恢复上一级原样\t    zoomer-&gt;setMousePattern( QwtEventPattern::MouseSelect3, Qt::RightButton, Qt::ControlModifier );//左键 放大\t右键恢复原样 ctrl+右键恢复上一级原样    zoomer-&gt;setMousePattern( QwtEventPattern::MouseSelect3, Qt::LeftButton );//左键放大与左键恢复重叠 不推荐使用    zoomer-&gt;setMousePattern( QwtEventPattern::MouseSelect3, Qt::RightButton );//左键放大\t右键恢复原样与恢复上一级原样重叠· 右键恢复原样覆盖恢复上一级原样","categories":[],"tags":[]},{"title":"OpenCV3.0 + QT5.x 环境搭建","url":"http://example.com/2017/06/20/OpenCV3.0 + QT5.x 环境搭建/","content":"OpenCV网站上对windows只提供了VS的预编译解压包, 因此需要自己编译OpenCV的源码, 以在QT环境下使用. OpenCV的编译对编译器版本要求比较严格, 因此在编译时绕了不少弯路, 浪费了不少时间, 现在把所得经验分享出来.本文末附编译好的OpenCV3.0, 方便大家.\n\n编译环境:OpenCV 3.0QT5.3.2 with MinGW4.8.2(32bit)CMake2.8.8Windows7 32bit\n\n注: opencv3.1及以上不再支持32位. 本文编译流程在Win8及更高版本Windows下均有兼容性问题. 但编译好的OpenCV可以在更高版本Windows上完美使用. 本文截图在Win10上完成.\n\n编译步骤:1.1 安装CMake2.8.8, 安装QT5.3.2并确认MinGW版本, 下载并安装OpenCV WinPack1.2 将QT下的相应目录添加进Path变量2.1 打开CMake后勾选Grouped, Advanced, 并选择安装的OpenCV源代码目录和编译生成目录.2.2 点击Configure, 出现下图对话框. 选择MinGW Makefiles, 选中Specify native compilers2.3 继续下一步, 弹出如下对话框, 选择编译器, C编译器选择QT安装目录下的.\\Tools\\mingw530_32\\bin\\gcc.exe. C++编译器选择QT安装目录下的.\\Tools\\mingw530_32\\bin\\g++.exe, 继续下一步.2.4 点击Finish, 等待预编译完成. 过程中可能会报错 Error in configuration process, project files may be invalid. 忽略即可.3.1 展开WITH列表, 将WITH_IPP去除勾选, 勾选WITH_QT和WITH_OPENGL3.2 点击Generate, 等待编译完成4.0 打开OpenCV源文件文件夹中CMake目录下的Opencvcompileroptions.cmake文件搜索找到add_extra_compiler_option(-Werror=non-virtual-dtor), 在该行前面加上#号注释掉这一行. 在OpenCV3.0版本下该行为67行.5.1 打开命令行管理器进入生成文件夹, 执行 mingw32-make5.2 执行完成后继续输入 mingw32-make install等待进度完成之后, 编译工作便完成了我们将目标文件夹中的install\\include文件夹和bin及lib文件夹复制出来, 这些便是以后进行OpenCV开发所需要的文件.此处我将文件复制到了一个命名为FilesNeededByOpenCV的文件夹中, 将此文件夹中的bin文件夹添加到系统Path变量中.可将此文件夹打包, 用于其他版本Windows环境下的开发.如果一切顺利, 则配置完成.\n测试:新建一个QT项目, 在pro文件中加入INCLUDEPATH += &quot;C:\\FilesNeededByOpenCV\\include\\opencv&quot; INCLUDEPATH += &quot;C:\\FilesNeededByOpenCV\\include\\opencv2&quot; INCLUDEPATH += &quot;C:\\FilesNeededByOpenCV\\include&quot; LIBS += &quot;C:\\FilesNeededByOpenCV\\lib\\libopencv_*.a&quot;其中文件路径替换为你上步操作实际选择的文件夹\n#include &lt;opencv2/opencv.hpp&gt; using namespace cv; int main()&#123;     Mat srcImage = imread(&quot;1.jpg&quot;);     imshow(&quot;IMAGE&quot;, srcImage);     waitKey(0); &#125;运行成功!\n最后:附上打包的预编译文件https://drive.google.com/open?id=0B7VyGeuv2EoGUmJuSUxPMVB6Z2s\n","categories":[],"tags":[]},{"title":"当你在浏览器中输入Google.com并且按下回车之后发生了什么？","url":"http://example.com/2017/03/21/当你在浏览器中输入Google.com并且按下回车之后发生了什么？/","content":"原文来源@marumari译文来源@skyline75489这个文章试图回答一个古老的面试问题：当你在浏览器中输入 google.com 并且按下回车之后发生了什么？\n\n不过我们不再局限于平常的回答，而是想办法回答地尽可能具体，不遗漏任何细节。\n这将是一个协作的过程，所以深入挖掘吧，并且帮助我们一起完善它。仍然有大量的细节等待着你来添加，欢迎向我们发送 Pull Requset！\n这些内容使用 Creative Commons Zero_ 协议发布。\n按下”g”键接下来的内容介绍了物理键盘和系统中断的工作原理，但是有一部分内容却没有涉及。当你按下“g”键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。你打算输入 “google.com”，因此给出的建议并不匹配。但是输入过程中仍然有大量的代码在后台运行，你的每一次按键都会使得给出的建议更加准确。甚至有可能在你输入之前，浏览器就将 “google.com” 建议给你。\n回车键按下为了从零开始，我们选择键盘上的回车键被按到最低处作为起点。在这个时刻，一个专用于回车键的电流回路被直接地或者通过电容器间接地闭合了，使得少量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的电位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值是13。键盘控制器在得到码值之后，将其编码，用于之后的传输。现在这个传输过程几乎都是通过通用串行总线(USB)或者蓝牙(Bluetooth)来进行的，以前是通过PS/2或者ADB连接进行。\nUSB键盘：\n\n键盘的USB元件通过计算机上的USB接口与USB控制器相连接，USB接口中的第一号针为它提供了5V的电压\n\n键码值存储在键盘内部电路一个叫做”endpoint”的寄存器内\n\nUSB控制器大概每隔10ms便查询一次”endpoint”以得到存储的键码值数据，这个最短时间间隔由键盘提供\n\n键值码值通过USB串行接口引擎被转换成一个或者多个遵循低层USB协议的USB数据包\n\n这些数据包通过D+针或者D-针(中间的两个针)，以最高1.5Mb/s的速度从键盘传输至计算机。速度限制是因为人机交互设备总是被声明成”低速设备”（USB 2.0 compliance）\n\n这个串行信号在计算机的USB控制器处被解码，然后被人机交互设备通用键盘驱动进行进一步解释。之后按键的码值被传输到操作系统的硬件抽象层\n\n\n虚拟键盘（触屏设备）：\n\n在现代电容屏上，当用户把手指放在屏幕上时，一小部分电流从传导层的静电域经过手指传导，形成了一个回路，使得屏幕上触控的那一点电压下降，屏幕控制器产生一个中断，报告这次“点击”的坐标\n\n然后移动操作系统通知当前活跃的应用，有一个点击事件发生在它的某个GUI部件上了，现在这个部件是虚拟键盘的按钮\n\n虚拟键盘引发一个软中断，返回给OS一个“按键按下”消息\n\n这个消息又返回来向当前活跃的应用通知一个“按键按下”事件\n\n\n产生中断[非USB键盘]键盘在它的中断请求线(IRQ)上发送信号，信号会被中断控制器映射到一个中断向量，实际上就是一个整型数 。CPU使用中断描述符表(IDT)把中断向量映射到对应函数，这些函数被称为中断处理器，它们由操作系统内核提供。当一个中断到达时，CPU根据IDT和中断向量索引到对应的中断处理器，然后操作系统内核出场了。\n(Windows)一个 WM_KEYDOWN 消息被发往应用程序HID把键盘按下的事件传送给 KBDHID.sys 驱动，把HID的信号转换成一个扫描码(Scancode)，这里回车的扫描码是 VK_RETURN(0x0d)。 KBDHID.sys 驱动和 KBDCLASS.sys (键盘类驱动,keyboard class driver)进行交互，这个驱动负责安全地处理所有键盘和小键盘的输入事件。之后它又去调用 Win32K.sys ，在这之前有可能把消息传递给安装的第三方键盘过滤器。这些都是发生在内核模式。\nWin32K.sys 通过 GetForegroundWindow() API函数找到当前哪个窗口是活跃的。这个API函数提供了当前浏览器的地址栏的句柄。Windows系统的”message pump”机制调用 SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam) 函数， lParam 是一个用来指示这个按键的更多信息的掩码，这些信息包括按键重复次数（这里是0），实际扫描码（可能依赖于OEM厂商，不过通常不会是 VK_RETURN ），功能键（alt, shift, ctrl）是否被按下（在这里没有），以及一些其他状态。\nWindows的 SendMessage API直接将消息添加到特定窗口句柄 hWnd 的消息队列中，之后赋给 hWnd 的主要消息处理函数 WindowProc 将会被调用，用于处理队列中的消息。\n当前活跃的句柄 hWnd 实际上是一个edit control控件，这种情况下，WindowProc 有一个用于处理 WM_KEYDOWN 消息的处理器，这段代码会查看 SendMessage 传入的第三个参数 wParam ，因为这个参数是 VK_RETURN ，于是它知道用户按下了回车键。\n(Mac OS X)一个 KeyDown NSEvent被发往应用程序中断信号引发了I/O Kit Kext键盘驱动的中断处理事件，驱动把信号翻译成键码值，然后传给OS X的 WindowServer 进程。然后， WindowServer 将这个事件通过Mach端口分发给合适的（活跃的，或者正在监听的）应用程序，这个信号会被放到应用程序的消息队列里。队列中的消息可以被拥有足够高权限的线程使用 mach_ipc_dispatch 函数读取到。这个过程通常是由 NSApplication 主事件循环产生并且处理的，通过 NSEventType 为 KeyDown 的 NSEvent 。\n(GNU/Linux)Xorg 服务器监听键码值当使用图形化的 X Server 时，X Server 会按照特定的规则把键码值再一次映射，映射成扫描码。当这个映射过程完成之后， X Server 把这个按键字符发送给窗口管理器(DWM，metacity, i3等等)，窗口管理器再把字符发送给当前窗口。当前窗口使用有关图形API把文字打印在输入框内。\n解析URL\n浏览器通过 URL 能够知道下面的信息：\n\nProtocol “http”  使用HTTP协议\nResource “/“  请求的资源是主页(index)\n\n\n\n输入的是 URL 还是搜索的关键字？当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。\n转换非 ASCII 的 Unicode 字符\n浏览器检查输入是否含有不是 a-z， A-Z，0-9， - 或者 . 的字符\n这里主机名是 google.com ，所以没有非ASCII的字符；如果有的话，浏览器会对主机名部分使用 Punycode_  编码\n\n检查 HSTS 列表···\n浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站\n如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送\n注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户收到 downgrade attack_ 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。\n\nDNS 查询···\n浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome://net-internals/#dns &lt;chrome://net-internals/#dns&gt;_）。\n\n如果缓存中没有，就去调用 gethostbyname 库函数（操作系统不同函数也不同）进行查询。\n\ngethostbyname 函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置 不同的操作系统有所不同_\n\n如果 gethostbyname 没有这个域名的缓存记录，也没有在 hosts 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。\n\n查询本地 DNS 服务器\n\n如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询\n\n如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询\n\n\nARP 过程要想发送 ARP（地址解析协议）广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。\n\n首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC\n\n如果缓存没有命中：\n\n查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。\n查询选择的网络接口的 MAC 地址\n我们发送一个二层（ OSI 模型_ 中的数据链路层）ARP 请求：\n\nARP Request::\nSender MAC: interface:mac:address:here\nSender IP: interface.ip.goes.here\nTarget MAC: FF:FF:FF:FF:FF:FF (Broadcast)\nTarget IP: target.ip.goes.here\n根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：\n直连：\n\n如果我们和路由器是直接连接的，路由器会返回一个 ARP Reply （见下面）。\n\n集线器：\n\n如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个 ARP Reply 。\n\n交换机：\n\n如果我们连接到了一个交换机，交换机会检查本地 CAM/MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。\n如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 ARP 请求\n如果路由器也“连接”在其中，它会返回一个 ARP Reply\n\nARP Reply::\nSender MAC: target:mac:address:here\nSender IP: target.ip.goes.here\nTarget MAC: interface:mac:address:here\nTarget IP: interface.ip.goes.here\n现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了：\n\n使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议\n如果本地/ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回\n\n使用套接字当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数 socket ，请求一个TCP流套接字，对应的参数是 AF_INET/AF_INET6 和 SOCK_STREAM 。\n\n这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range)\nTCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个TCP packet。\n这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame头 部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。\n\n到了现在，TCP 封包已经准备好了，可以使用下面的方式进行传输：\n\n以太网_\nWiFi_\n蜂窝数据网络_\n\n对于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适于在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个 网络节点_ 处理。节点的目标地址和源地址将在后面讨论。\n大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个 网络节点_ 进行处理。\n最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP数据报头部TTL域的值每经过一个路由器就减1，如果封包的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。\n上面的发送和接受过程在 TCP 连接期间会发生很多次：\n\n客户端选择一个初始序列号(ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号\n服务器端接收到 SYN 包，如果它可以建立连接：\n服务器端选择它自己的初始序列号\n服务器端设置 SYN 位，表明自己选择了一个初始序列号\n服务器端把 (客户端ISN + 1) 复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个封包\n\n\n客户端通过发送下面一个封包来确认这次连接：\n自己的序列号+1\n接收端 ACK+1\n设置 ACK 位\n\n\n数据通过下面的方式传输：\n当一方发送了N个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N\n另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号\n\n\n关闭连接时：\n要关闭连接的一方发送一个 FIN 包\n另一方确认这个 FIN 包，并且发送自己的 FIN 包\n要关闭的一方使用 ACK 包来确认接收到了 FIN\n\n\n\nUDP 数据包\n\nTLS 握手\n--------\n* 客户端发送一个 ``Client hello`` 消息到服务器端，消息中同时包含了它的TLS版本，可用的加密算法和压缩算法。\n* 服务器端向客户端返回一个 ``Server hello`` 消息，消息中包含了服务器端的TLS版本，服务器选择了哪个加密和压缩算法，以及服务器的公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥\n* 客户端根据自己的信任CA列表，验证服务器端的证书是否有效。如果有效，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥\n* 服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥\n* 客户端发送一个 ``Finished`` 消息给服务器端，使用对称密钥加密这次通讯的一个散列值\n* 服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 ``Finished`` 消息，也使用协商好的对称密钥加密\n* 从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容\n\nTCP 数据包\nHTTP 协议···如果浏览器是 Google 出品的，它不会使用 HTTP 协议来获取页面信息，而是会与服务器端发送请求，商讨使用 SPDY 协议。\n如果浏览器使用 HTTP 协议，它会向服务器发送这样的一个请求::\nGET / HTTP/1.1\nHost: google.com\n[其他头部]\n“其他头部”包含了一系列的由冒号分割开的键值对，它们的格式符合HTTP协议标准，它们之间由一个换行符分割开来。这里我们假设浏览器没有违反HTTP协议标准的bug，同时浏览器使用 HTTP/1.1 协议，不然的话头部可能不包含 Host 字段，同时 GET 请求中的版本号会变成 HTTP/1.0 或者 HTTP/0.9 。\nHTTP/1.1 定义了“关闭连接”的选项 “close”，发送者使用这个选项指示这次连接在响应结束之后会断开::\nConnection:close\n不支持持久连接的 HTTP/1.1 必须在每条消息中都包含 “close” 选项。 \n在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。\n服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的::\n200 OK\n[响应头部]\n然后是一个换行，接下来有效载荷(payload)，也就是 www.google.com 的HTML内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供以后的请求重用。\n如果浏览器发送的HTTP头部包含了足够多的信息（例如包含了 Etag 头部，以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应::\n304 Not Modified\n[响应头部]\n这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容。\n在解析完 HTML 之后，浏览器和客户端会重复上面的过程，直到HTML页面引入的所有资源（图片，CSS，favicon.ico等等）全部都获取完毕，区别只是头部的 GET / HTTP/1.1 会变成 GET /$(相对www.google.com的URL) HTTP/1.1 。 \n如果HTML引入了 www.google.com 域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 Host 头部会变成另外的域名。\nHTTP 服务器请求处理HTTPD(HTTP Daemon)在服务器端处理请求/响应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。\n\nHTTPD 接收请求\n服务器把请求拆分为以下几个参数：\nHTTP 请求方法(GET, POST, HEAD, PUT, DELETE, CONNECT, OPTIONS, 或者 TRACE)。直接在地址栏中输入 URL 这种情况下，使用的是 GET 方法\n域名：google.com\n请求路径/页面：/  (我们没有请求google.com下的指定的页面，因此 / 是默认的路径)\n\n\n服务器验证其上已经配置了 google.com 的虚拟主机\n服务器验证 google.com 接受 GET 方法\n服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等)\n如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求\n服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 “/“ ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）。\n服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者\n\n浏览器背后的故事当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：\n\n解析 —— HTML，CSS，JS\n渲染 —— 构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制\n\n浏览器浏览器的功能是从服务器上取回你想要的资源，然后展示在浏览器窗口当中。资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。资源的位置通过用户提供的 URI(Uniform Resource Identifier) 来确定。\n浏览器解释和展示 HTML 文件的方法，在 HTML 和 CSS 的标准中有详细介绍。这些标准由 Web 标准组织 W3C(World Wide Web Consortium) 维护。\n不同浏览器的用户界面大都十分接近，有很多共同的 UI 元素：\n\n一个地址栏\n后退和前进按钮\n书签选项\n刷新和停止按钮\n主页按钮\n\n浏览器高层架构\n组成浏览器的组件有：\n\n用户界面 用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分\n浏览器引擎 浏览器引擎负责让 UI 和渲染引擎协调工作\n渲染引擎 渲染引擎负责展示请求内容。如果请求的内容是 HTML，渲染引擎会解析 HTML 和 CSS，然后将内容展示在屏幕上\n网络组件 网络组件负责网络调用，例如 HTTP 请求等，使用一个平台无关接口，下层是针对不同平台的具体实现\nUI后端 UI 后端用于绘制基本 UI 组件，例如下拉列表框和窗口。UI 后端暴露一个统一的平台无关的接口，下层使用操作系统的 UI 方法实现\nJavascript 引擎 Javascript 引擎用于解析和执行 Javascript 代码\n数据存储 数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如 Cookie 等。浏览器也需要支持诸如 localStorage，IndexedDB，WebSQL 和 FileSystem 之类的存储机制\n\nHTML 解析浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成8kB大小的分块传输。\nHTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。\n解析树是以 DOM 元素以及属性为节点的树。DOM是文档对象模型(Document Object Model)的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部(如Javascript)的接口。树的根部是”Document”对象。整个 DOM 和 HTML 文档几乎是一对一的关系。\n解析算法\nHTML不能使用常见的自顶向下或自底向上方法来进行分析。主要原因有以下几点:\n\n语言本身的“宽容”特性\nHTML 本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们\n解析过程需要反复。对于其他语言来说，源码不会在解析过程中发生变化，但是对于 HTML 来说，动态代码，例如脚本元素中包含的 document.write() 方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容\n\n由于不能使用常用的解析技术，浏览器创造了专门用于解析 HTML 的解析器。解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。\n解析结束之后\n浏览器开始加载网页的外部资源（CSS，图像，Javascript 文件等）。\n此时浏览器把文档标记为“可交互的”，浏览器开始解析处于“推迟”模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为“完成”，浏览器会进行“加载”事件。\n注意解析 HTML 网页时永远不会出现“语法错误”，浏览器会修复所有错误，然后继续解析。\n执行同步 Javascript 代码。\nCSS 解析\n根据 CSS词法和句法_ 分析CSS文件和 &lt;style&gt; 标签包含的内容\n每个CSS文件都被解析成一个样式表对象，这个对象里包含了带有选择器的CSS规则，和对应CSS语法的对象\nCSS解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器\n\n页面渲染\n通过遍历DOM节点树创建一个“Frame 树”或“渲染树”，并计算每个节点的各个CSS样式值\n通过累加子节点的宽度，该节点的水平内边距(padding)、边框(border)和外边距(margin)，自底向上的计算”Frame 树”中每个节点首的选(preferred)宽度\n通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度\n通过应用文字折行、累加子节点的高度和此节点的内边距(padding)、边框(border)和外边距(margin)，自底向上的计算每个节点的高度\n使用上面的计算结果构建每个节点的坐标\n当存在元素使用 floated，位置有 absolutely 或 relatively 属性的时候，会有更多复杂的计算，详见http://dev.w3.org/csswg/css2/ 和 http://www.w3.org/Style/CSS/current-work\n创建layer(层)来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层\n页面上的每个层都被分配了纹理(?)\n每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由CPU执行栅格化处理，或者直接通过D2D/SkiaGL在GPU上绘制\n上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量\n计算出各个层的最终位置，一组命令由 Direct3D/OpenGL发出，GPU命令缓冲区清空，命令传至GPU并异步渲染，帧被送到Window Server。\n\nGPU 渲染\n在渲染过程中，图形处理层可能使用通用用途的 CPU，也可能使用图形处理器 GPU\n当使用 GPU 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 GPU 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。\n\nWindow Server后期渲染与用户引发的处理渲染结束后，浏览器根据某些时间机制运行JavaScript代码(比如Google Doodle动画)或与用户交互(在搜索栏输入关键字获得搜索建议)。类似Flash和Java的插件也会运行，尽管Google主页里没有。这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制。\n.. Creative Commons Zero: https://creativecommons.org/publicdomain/zero/1.0/.. _CSS词法和句法: http://www.w3.org/TR/CSS2/grammar.html.. _Punycode: https://en.wikipedia.org/wiki/Punycode.. _以太网: http://en.wikipedia.org/wiki/IEEE_802.3.. _WiFi: https://en.wikipedia.org/wiki/IEEE_802.11.. _蜂窝数据网络: https://en.wikipedia.org/wiki/Cellular_data_communication_protocol.. _analog-to-digital converter: https://en.wikipedia.org/wiki/Analog-to-digital_converter.. _网络节点: https://en.wikipedia.org/wiki/Computer_network#Network_nodes.. _不同的操作系统有所不同 : https://en.wikipedia.org/wiki/Hosts%28file%29#Location_in_the_file_system.. _downgrade attack: http://en.wikipedia.org/wiki/SSL_stripping.. _OSI 模型: https://en.wikipedia.org/wiki/OSI_model\n","categories":[],"tags":[]},{"title":"Random.org---真·随机数","url":"http://example.com/2017/03/19/Random.org---真·随机数/","content":"\nRandomness is the lack of pattern or predictability in events. A random sequence of events, symbols or steps has no order and does not follow an intelligible pattern or combination.\n\n随机随机是统计学上的一个概念: 无序且不可预测.  随机数在实际开发中用于抽奖, 摇号等希望机器做出随机行为的场景. 在蒙特卡洛模拟算法和一些密码学的领域中, 对随机数有着更大量且高质的要求.\n\n大多数的计算机编程语言都提供了随机数生成函数, 可以提供”看起来随机”的数列.这类随机数其实被称为伪随机数, 它们是通过一个初始的”种子”(通常是系统的时间戳), 经过一系列数学运算得到的. 它们在数学上是可以准确预测和重现的, 在通常情况下, 伪随机数已经足以应付大多数应用场景. 严格意义上的随机数是物理现象产生的, 比如掷硬币, 骰子, 抽签, 剪刀石头布(误), 电子元件的噪音, 核裂变, 量子观测等等.\nFun Fact类Unix系统中维护了一个随机熵池, 收集计算机运行过程中产生的各种不可预测的噪声, 如:计算机运行过程中键盘敲击的时间间隔, 鼠标的移动轨迹, 内存的使用量, 文件的访问频率等等. 这些计算机运行过程中完全不可预测的行为, 被内核获取且添加进熵池, 在你向内核获取随机数时, 内核便会以这个熵池中的数据为种子, 生成随机数. 在Linux中获取随机数非常简单, 只需要访问/dev/random 文件就可以了.\n提供随机数的服务Random.org借助自然现象的随机性, 引入无法预测的大气噪声(Atmospheric Noise), 提供随机数生成服务, 网站也提供了相应的API和开发文档用于向其获取随机数.API调用需要申请Key, 申请的过程也非常简单, 填个邮箱就可以了.但是临时调用也可以用Http访问这个链接https://www.random.org/cgi-bin/randbyte?nbytes=16384&amp;format=f, 服务器将返回16Kb的二进制随机数列文件.\nFurther Reading\nhttp://www.cnblogs.com/hehehu/archive/2005/08/23/221125.html\nhttps://en.wikipedia.org/wiki/Randomness\nhttps://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%95%B0\n\n","categories":[],"tags":[]},{"title":"Hello,Blog","url":"http://example.com/2017/03/12/Hello,Blog/","content":"听说考试后放了个小假, 花点时间简单搭了个Blog. 既是草稿纸, 也是知识库, 期待我会慢慢堆内容吧XD\n","categories":[],"tags":[]}]